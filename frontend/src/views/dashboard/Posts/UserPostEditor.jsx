import { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import PropTypes from 'prop-types';

// MUI
import Box from '@mui/material/Box';
import Dialog from '@mui/material/Dialog';
import DialogTitle from '@mui/material/DialogTitle';
import DialogContent from '@mui/material/DialogContent';
import DialogActions from '@mui/material/DialogActions';
import Button from '@mui/material/Button';
import Typography from '@mui/material/Typography';
import Stack from '@mui/material/Stack';
import FormControl from '@mui/material/FormControl';
import InputLabel from '@mui/material/InputLabel';
import Select from '@mui/material/Select';
import MenuItem from '@mui/material/MenuItem';
import Chip from '@mui/material/Chip';
import CircularProgress from '@mui/material/CircularProgress';
import Alert from '@mui/material/Alert';

// Components
import BlockEditor from '@/components/editor/BlockEditor';
import FloatingToolbar from '@/components/editor/FloatingToolbar';
import PostSettingsSidebar from '@/components/editor/PostSettingsSidebar';

// API
import { createPost, updatePost, getPost, getImageUrl } from '@/api/services/postService';
import { getCategories } from '@/api/services/categoryService';
import { getTags } from '@/api/services/tagService';

// Utils
import {
  extractTitle,
  calculateWordCount,
  calculateReadingTime,
  generateExcerpt,
  extractPlainText,
  isEditorEmpty,
} from '@/utils/editorUtils';

/**
 * UserPostEditor - Medium-style distraction-free writing experience
 */
export default function UserPostEditor() {
  const navigate = useNavigate();
  const { id } = useParams();
  const isEditing = Boolean(id);

  // Editor state
  const [editorData, setEditorData] = useState(null);
  const [settingsOpen, setSettingsOpen] = useState(false);
  const [isDirty, setIsDirty] = useState(false);
  const [isPublishing, setIsPublishing] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Metadata state
  const [useAutoExcerpt, setUseAutoExcerpt] = useState(true);
  const [manualExcerpt, setManualExcerpt] = useState('');
  const [categoryId, setCategoryId] = useState('');
  const [selectedTags, setSelectedTags] = useState([]);
  const [metaTitle, setMetaTitle] = useState('');
  const [metaDescription, setMetaDescription] = useState('');
  const [customReadingTime, setCustomReadingTime] = useState(null);
  const [featuredImage, setFeaturedImage] = useState(null);

  // Auto-save state
  const [saveStatus, setSaveStatus] = useState('idle');
  const [lastSaved, setLastSaved] = useState(null);
  const autoSaveTimeoutRef = useRef(null);
  const postIdRef = useRef(id);

  // Publish dialog state
  const [publishDialogOpen, setPublishDialogOpen] = useState(false);
  const [publishCategoryId, setPublishCategoryId] = useState('');
  const [publishTags, setPublishTags] = useState([]);
  const [publishFeaturedFile, setPublishFeaturedFile] = useState(null);
  const [publishFeaturedPreview, setPublishFeaturedPreview] = useState(null);

  // Data
  const [categories, setCategories] = useState([]);
  const [tags, setTags] = useState([]);
  const [categoriesLoading, setCategoriesLoading] = useState(false);
  const [tagsLoading, setTagsLoading] = useState(false);

  // Computed values
  const stats = useMemo(() => {
    if (!editorData?.blocks) return { wordCount: 0, readingTime: 1 };
    const wordCount = calculateWordCount(editorData);
    const readingTime = customReadingTime || calculateReadingTime(wordCount);
    return { wordCount, readingTime };
  }, [editorData, customReadingTime]);

  const autoGeneratedExcerpt = useMemo(() => {
    if (!editorData?.blocks) return '';
    return generateExcerpt(editorData, 150);
  }, [editorData]);

  const extractedTitle = useMemo(() => {
    if (!editorData?.blocks) return '';
    return extractTitle(editorData);
  }, [editorData]);

  // Load categories and tags
  useEffect(() => {
    const loadData = async () => {
      try {
        setCategoriesLoading(true);
        setTagsLoading(true);
        const [catRes, tagRes] = await Promise.all([
          getCategories(),
          getTags()
        ]);
        setCategories(catRes.categories || catRes || []);
        setTags(tagRes.tags || tagRes || []);
      } catch (err) {
        console.error('Failed to load categories/tags:', err);
      } finally {
        setCategoriesLoading(false);
        setTagsLoading(false);
      }
    };
    loadData();
  }, []);

  // Load post for editing
  useEffect(() => {
    if (isEditing && id) {
      const loadPost = async () => {
        try {
          setLoading(true);
          const post = await getPost(id);
          
          // Set editor data
          if (post.content_blocks) {
            setEditorData(post.content_blocks);
          } else if (post.content) {
            // Will be converted by BlockEditor
            setEditorData({ html: post.content });
          }

          // Set metadata
          setManualExcerpt(post.excerpt || '');
          setCategoryId(post.category?.id || post.category_id || '');
          setSelectedTags(post.tags?.map(t => t.id) || []);
          setMetaTitle(post.meta_title || '');
          setMetaDescription(post.meta_description || '');
          setCustomReadingTime(post.reading_time || null);
          
          if (post.featured_image) {
            setPublishFeaturedPreview(getImageUrl(post.featured_image));
          }
          
          postIdRef.current = id;
        } catch (err) {
          console.error('Failed to load post:', err);
          setError('Failed to load post');
        } finally {
          setLoading(false);
        }
      };
      loadPost();
    }
  }, [id, isEditing]);

  // Handle editor changes
  const handleEditorChange = useCallback((contentData) => {
    setEditorData(contentData.blocks);
    setIsDirty(true);

    // Auto-save after 5 seconds of inactivity
    if (autoSaveTimeoutRef.current) {
      clearTimeout(autoSaveTimeoutRef.current);
    }
    if (!settingsOpen) {
      autoSaveTimeoutRef.current = setTimeout(() => {
        handleAutoSave(contentData);
      }, 5000);
    }
  }, [settingsOpen]);

  // Auto-save function
  const handleAutoSave = useCallback(async (contentData) => {
    if (!contentData?.blocks || isEditorEmpty(contentData.blocks)) return;
    if (settingsOpen) return;

    try {
      setSaveStatus('saving');

      const formData = new FormData();
      formData.append('title', extractTitle(contentData.blocks) || 'Untitled');
      formData.append('content', contentData.html || '');
      formData.append('content_blocks', JSON.stringify(contentData.blocks));
      formData.append('excerpt', useAutoExcerpt ? generateExcerpt(contentData.blocks, 150) : manualExcerpt);
      formData.append('is_published', 'false');
      
      if (categoryId) formData.append('category_id', categoryId);
      if (selectedTags.length) formData.append('tag_ids', selectedTags.join(','));

      if (postIdRef.current) {
        await updatePost(postIdRef.current, formData);
      } else {
        const result = await createPost(formData);
        postIdRef.current = result.uuid;
        // Update URL without navigation
        window.history.replaceState(null, '', `/dashboard/posts/edit/${result.uuid}`);
      }

      setSaveStatus('saved');
      setLastSaved(Date.now());
      setIsDirty(false);
    } catch (err) {
      console.error('Auto-save failed:', err);
      setSaveStatus('error');
    }
  }, [settingsOpen, useAutoExcerpt, manualExcerpt, categoryId, selectedTags]);

  // Open publish dialog
  const handleOpenPublish = useCallback(() => {
    setPublishCategoryId(categoryId || '');
    setPublishTags(selectedTags || []);
    setPublishFeaturedFile(null);
    setPublishDialogOpen(true);
  }, [categoryId, selectedTags]);

  // Publish post
  const handlePublish = useCallback(async () => {
    if (!editorData?.blocks || isEditorEmpty(editorData)) {
      setError('Please write some content before publishing');
      return;
    }

    const plainText = extractPlainText(editorData);
    if (plainText.length < 50) {
      setError('Content must be at least 50 characters');
      return;
    }

    try {
      setIsPublishing(true);
      setPublishDialogOpen(false);

      const formData = new FormData();
      formData.append('title', extractedTitle || 'Untitled');
      formData.append('content', editorData.html || '');
      formData.append('content_blocks', JSON.stringify(editorData));
      formData.append('excerpt', useAutoExcerpt ? autoGeneratedExcerpt : manualExcerpt);
      formData.append('meta_title', metaTitle || '');
      formData.append('meta_description', metaDescription || '');
      formData.append('reading_time', String(stats.readingTime));
      formData.append('is_published', 'true');

      if (publishCategoryId) formData.append('category_id', publishCategoryId);
      if (publishTags.length) formData.append('tag_ids', publishTags.join(','));
      if (publishFeaturedFile) formData.append('featured_image', publishFeaturedFile);

      if (postIdRef.current) {
        await updatePost(postIdRef.current, formData);
      } else {
        await createPost(formData);
      }

      navigate('/dashboard/posts');
    } catch (err) {
      console.error('Failed to publish:', err);
      setError(err.response?.data?.detail || 'Failed to publish post');
    } finally {
      setIsPublishing(false);
    }
  }, [
    editorData, extractedTitle, useAutoExcerpt, autoGeneratedExcerpt,
    manualExcerpt, metaTitle, metaDescription, stats.readingTime,
    publishCategoryId, publishTags, publishFeaturedFile, navigate
  ]);

  // Handle tag toggle
  const handleTagToggle = useCallback((tagId) => {
    setSelectedTags(prev => {
      const newTags = prev.includes(tagId)
        ? prev.filter(id => id !== tagId)
        : [...prev, tagId];
      setIsDirty(true);
      return newTags;
    });
  }, []);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === ',') {
        e.preventDefault();
        setSettingsOpen(true);
      }
      if (e.key === 'Escape' && settingsOpen) {
        setSettingsOpen(false);
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [settingsOpen]);

  // Warn about unsaved changes
  useEffect(() => {
    const handleBeforeUnload = (e) => {
      if (isDirty) {
        e.preventDefault();
        e.returnValue = 'You have unsaved changes.';
        return e.returnValue;
      }
    };
    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [isDirty]);

  // Cleanup
  useEffect(() => {
    return () => {
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
    };
  }, []);

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '60vh' }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box sx={{ minHeight: '100vh', bgcolor: 'background.default' }}>
      {/* Floating Toolbar */}
      <FloatingToolbar
        onPublish={handleOpenPublish}
        onOpenSettings={() => setSettingsOpen(true)}
        saveStatus={saveStatus}
        lastSaved={lastSaved}
        isPublishing={isPublishing}
        wordCount={stats.wordCount}
        readingTime={stats.readingTime}
      />

      {/* Error Alert */}
      {error && (
        <Box sx={{ p: 2 }}>
          <Alert severity="error" onClose={() => setError(null)}>
            {error}
          </Alert>
        </Box>
      )}

      {/* Main Editor Area */}
      <Box sx={{ maxWidth: 800, mx: 'auto', py: 4, px: 3 }}>
        <BlockEditor
          value={editorData}
          onChange={handleEditorChange}
          placeholder="Start with a title or just begin writing..."
          fullHeight
          minHeight={500}
        />
      </Box>

      {/* Settings Sidebar */}
      <PostSettingsSidebar
        isOpen={settingsOpen}
        onClose={() => setSettingsOpen(false)}
        excerpt={manualExcerpt}
        autoExcerpt={autoGeneratedExcerpt}
        useAutoExcerpt={useAutoExcerpt}
        onExcerptModeChange={setUseAutoExcerpt}
        onExcerptChange={setManualExcerpt}
        categories={categories}
        categoryId={categoryId}
        onCategoryChange={setCategoryId}
        tags={tags}
        selectedTags={selectedTags}
        onTagToggle={handleTagToggle}
        metaTitle={metaTitle}
        metaDescription={metaDescription}
        readingTime={stats.readingTime}
        onMetaChange={(updates) => {
          if (updates.metaTitle !== undefined) setMetaTitle(updates.metaTitle);
          if (updates.metaDescription !== undefined) setMetaDescription(updates.metaDescription);
          if (updates.readingTime !== undefined) setCustomReadingTime(updates.readingTime);
          setIsDirty(true);
        }}
        categoriesLoading={categoriesLoading}
        tagsLoading={tagsLoading}
      />

      {/* Publish Dialog */}
      <Dialog
        open={publishDialogOpen}
        onClose={() => setPublishDialogOpen(false)}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>Ready to publish?</DialogTitle>
        <DialogContent>
          <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
            Choose category, up to 5 tags, and a feature image.
          </Typography>

          <Stack spacing={3}>
            {/* Category */}
            <FormControl fullWidth size="small">
              <InputLabel>Category</InputLabel>
              <Select
                value={publishCategoryId}
                onChange={(e) => setPublishCategoryId(e.target.value)}
                label="Category"
              >
                <MenuItem value="">No category</MenuItem>
                {categories.map((cat) => (
                  <MenuItem key={cat.id} value={cat.id}>{cat.name}</MenuItem>
                ))}
              </Select>
            </FormControl>

            {/* Tags */}
            <Box>
              <Stack direction="row" justifyContent="space-between" alignItems="center" sx={{ mb: 1 }}>
                <Typography variant="subtitle2">Tags</Typography>
                <Typography variant="caption" color="text.secondary">
                  {publishTags.length}/5
                </Typography>
              </Stack>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                {tags.map((tag) => {
                  const isSelected = publishTags.includes(tag.id);
                  const isDisabled = !isSelected && publishTags.length >= 5;
                  return (
                    <Chip
                      key={tag.id}
                      label={tag.name}
                      size="small"
                      clickable={!isDisabled}
                      color={isSelected ? 'primary' : 'default'}
                      variant={isSelected ? 'filled' : 'outlined'}
                      disabled={isDisabled}
                      onClick={() => {
                        if (isDisabled) return;
                        setPublishTags(prev =>
                          prev.includes(tag.id)
                            ? prev.filter(id => id !== tag.id)
                            : [...prev, tag.id]
                        );
                      }}
                    />
                  );
                })}
              </Box>
            </Box>

            {/* Featured Image */}
            <Box>
              <Typography variant="subtitle2" sx={{ mb: 1 }}>Feature Image</Typography>
              <Box
                sx={{
                  border: '2px dashed',
                  borderColor: 'divider',
                  borderRadius: 1,
                  p: 2,
                  textAlign: 'center',
                }}
              >
                {publishFeaturedPreview ? (
                  <Box
                    component="img"
                    src={publishFeaturedPreview}
                    alt="Preview"
                    sx={{ maxHeight: 160, mx: 'auto', borderRadius: 1 }}
                  />
                ) : (
                  <Typography variant="caption" color="text.secondary">
                    Optional. JPG/PNG/GIF/WEBP up to 5MB.
                  </Typography>
                )}
                <input
                  type="file"
                  accept="image/*"
                  onChange={(e) => {
                    const file = e.target.files?.[0];
                    if (!file) return;
                    if (!file.type.startsWith('image/')) {
                      setError('Please select an image file');
                      return;
                    }
                    if (file.size > 5 * 1024 * 1024) {
                      setError('Image must be under 5MB');
                      return;
                    }
                    setPublishFeaturedFile(file);
                    const reader = new FileReader();
                    reader.onload = (ev) => setPublishFeaturedPreview(ev.target.result);
                    reader.readAsDataURL(file);
                  }}
                  style={{ marginTop: 12, width: '100%' }}
                />
              </Box>
            </Box>
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setPublishDialogOpen(false)}>Cancel</Button>
          <Button
            variant="contained"
            onClick={handlePublish}
            disabled={isPublishing}
            startIcon={isPublishing && <CircularProgress size={16} color="inherit" />}
          >
            {isPublishing ? 'Publishing...' : 'Publish'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
}

UserPostEditor.propTypes = {};
