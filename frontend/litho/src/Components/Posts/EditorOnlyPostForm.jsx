import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react'
import PropTypes from 'prop-types'

// Libraries
import { Formik, Form } from 'formik'
import * as Yup from 'yup'

// Components
import { BlockEditor } from '../Form/Form'
import FloatingToolbar from './FloatingToolbar'
import PostSettingsSidebar from './PostSettingsSidebar'

// API & Auth
import { useCategoriesRaw as useCategories, useTags } from '../../api/usePosts'

// Utilities
import {
    extractTitle,
    calculateWordCount,
    calculateReadingTime,
    generateExcerpt,
    extractPlainText
} from '../../utils/editorUtils'

// CSS
import "../../Assets/scss/components/_editor-only-post.scss"

// Validation schema (simplified - only validate content exists)
const EditorOnlySchema = Yup.object().shape({
    content: Yup.string()
        .min(50, 'Content must be at least 50 characters')
        .required('Content is required')
        .test('content-length', 'Content must be at least 50 characters', function(value) {
            const textContent = value ? value.replace(/<[^>]*>/g, '').trim() : '';
            return textContent.length >= 50;
        })
})

const EditorOnlyPostForm = ({
    initialValues = {},
    onSubmit,
    onSaveDraft,
    loading = false,
    isEditMode = false
}) => {
    // Form state
    const [editorData, setEditorData] = useState(null)
    const [settingsOpen, setSettingsOpen] = useState(false)
    const [isDirty, setIsDirty] = useState(false)
    const [isPublishing, setIsPublishing] = useState(false)
    
    // Metadata state
    const [featuredImage, setFeaturedImage] = useState(null)
    const [useAutoExcerpt, setUseAutoExcerpt] = useState(true)
    const [manualExcerpt, setManualExcerpt] = useState(initialValues.excerpt || '')
    const [categoryId, setCategoryId] = useState(initialValues.category_id || '')
    const [selectedTags, setSelectedTags] = useState(initialValues.tag_ids || [])
    const [metaTitle, setMetaTitle] = useState(initialValues.meta_title || '')
    const [metaDescription, setMetaDescription] = useState(initialValues.meta_description || '')
    const [customReadingTime, setCustomReadingTime] = useState(initialValues.reading_time || null)
    
    // Auto-save state
    const [saveStatus, setSaveStatus] = useState('idle')
    const [lastSaved, setLastSaved] = useState(null)
    const autoSaveTimeoutRef = useRef(null)

    // Publish dialog state
    const [publishOpen, setPublishOpen] = useState(false)
    const [publishCategoryId, setPublishCategoryId] = useState(initialValues.category_id || '')
    const [publishTags, setPublishTags] = useState(initialValues.tag_ids || [])
    const [publishFeaturedFile, setPublishFeaturedFile] = useState(null)
    const [publishFeaturedPreview, setPublishFeaturedPreview] = useState(null)
    
    // API hooks
    const { categories, loading: categoriesLoading } = useCategories()
    const { tags, loading: tagsLoading } = useTags()

    // Auto-computed values
    const stats = useMemo(() => {
        if (!editorData?.blocks) return { wordCount: 0, readingTime: 1 }
        
        const wordCount = calculateWordCount(editorData)
        const readingTime = customReadingTime || calculateReadingTime(wordCount)
        
        return { wordCount, readingTime }
    }, [editorData, customReadingTime])

    const autoGeneratedExcerpt = useMemo(() => {
        if (!editorData?.blocks) return ''
        return generateExcerpt(editorData, 150)
    }, [editorData])

    const extractedTitle = useMemo(() => {
        if (!editorData?.blocks) return ''
        return extractTitle(editorData)
    }, [editorData])

    // Handle editor content changes
    const handleContentChange = useCallback((contentData, setFieldValue) => {
        setEditorData(contentData.blocks)
        setFieldValue('content_blocks', contentData.blocks)
        setFieldValue('content', contentData.html)
        setIsDirty(true)
        
        // Trigger auto-save timer (debounced)
        if (autoSaveTimeoutRef.current) {
            clearTimeout(autoSaveTimeoutRef.current)
        }
        if (settingsOpen) return
        autoSaveTimeoutRef.current = setTimeout(() => {
            if (onSaveDraft) {
                handleAutoSave(contentData)
            }
        }, 5000)
    }, [onSaveDraft, settingsOpen])

    // Auto-save function
    const handleAutoSave = useCallback(async (contentData) => {
        if (!contentData?.blocks || contentData.blocks.length === 0) return
        if (settingsOpen) return
        
        try {
            setSaveStatus('saving')
            
            const draftData = {
                title: extractedTitle || 'Untitled',
                content: contentData.html,
                content_blocks: contentData.blocks,
                excerpt: useAutoExcerpt ? autoGeneratedExcerpt : manualExcerpt,
                category_id: categoryId,
                tag_ids: selectedTags,
                featured_image: featuredImage,
                meta_title: metaTitle,
                meta_description: metaDescription,
                reading_time: stats.readingTime,
                slug: '', // Will be auto-generated from title
                is_published: false,
                autosave: true
            }
            
            await onSaveDraft(draftData)
            setSaveStatus('saved')
            setLastSaved(Date.now())
            setIsDirty(false)
        } catch (error) {
            setSaveStatus('error')
        }
    }, [
        useAutoExcerpt,
        autoGeneratedExcerpt,
        manualExcerpt,
        categoryId,
        selectedTags,
        featuredImage,
        metaTitle,
        metaDescription,
        stats.readingTime,
        onSaveDraft,
        settingsOpen
    ])

    // Manual save draft
    const handleSaveDraft = useCallback(async (values) => {
        if (!editorData?.blocks || editorData.blocks.length === 0) {
            alert('Please write some content before saving')
            return
        }

        try {
            setSaveStatus('saving')
            
            const draftData = {
                title: extractedTitle || 'Untitled',
                content: values.content,
                content_blocks: values.content_blocks,
                excerpt: useAutoExcerpt ? autoGeneratedExcerpt : manualExcerpt,
                category_id: categoryId,
                tag_ids: selectedTags,
                featured_image: featuredImage,
                meta_title: metaTitle,
                meta_description: metaDescription,
                reading_time: stats.readingTime,
                slug: '', // Will be auto-generated from title
                is_published: false
            }
            
            await onSaveDraft(draftData)
            setSaveStatus('saved')
            setLastSaved(Date.now())
            setIsDirty(false)
        } catch (error) {
            setSaveStatus('error')
            alert(error.message || 'Failed to save draft')
        }
    }, [
        editorData,
        useAutoExcerpt,
        autoGeneratedExcerpt,
        manualExcerpt,
        categoryId,
        selectedTags,
        featuredImage,
        metaTitle,
        metaDescription,
        stats.readingTime,
        onSaveDraft
    ])

    // Publish post
    const handlePublish = useCallback(async (values, overrides = {}) => {
        if (!editorData?.blocks || editorData.blocks.length === 0) {
            alert('Please write some content before publishing')
            return
        }

        // Validate minimum content length
        const plainText = extractPlainText(editorData)
        if (plainText.length < 50) {
            alert('Content must be at least 50 characters')
            return
        }

        try {
            setIsPublishing(true)
            const effectiveCategoryId = overrides.categoryId !== undefined ? overrides.categoryId : categoryId
            const effectiveTags = overrides.tagIds !== undefined ? overrides.tagIds : selectedTags
            const effectiveFeatured = overrides.featuredFile !== undefined ? overrides.featuredFile : featuredImage
            const postData = {
                title: extractedTitle || 'Untitled',
                content: values.content,
                content_blocks: values.content_blocks,
                excerpt: useAutoExcerpt ? autoGeneratedExcerpt : manualExcerpt,
                category_id: effectiveCategoryId,
                tag_ids: effectiveTags,
                featured_image: effectiveFeatured,
                meta_title: metaTitle,
                meta_description: metaDescription,
                reading_time: stats.readingTime,
                slug: '', // Will be auto-generated from title
                is_published: true
            }
            
            await onSubmit(postData)
            setIsDirty(false)
        } catch (error) {
            alert(error.message || 'Failed to publish post')
        } finally {
            setIsPublishing(false)
        }
    }, [
        editorData,
        useAutoExcerpt,
        autoGeneratedExcerpt,
        manualExcerpt,
        categoryId,
        selectedTags,
        featuredImage,
        metaTitle,
        metaDescription,
        stats.readingTime,
        onSubmit
    ])

    // Featured image is selected via the Publish dialog only

    // Handle tag toggle
    const handleTagToggle = useCallback((tagId) => {
        setSelectedTags(prev => {
            const newTags = prev.includes(tagId)
                ? prev.filter(id => id !== tagId)
                : [...prev, tagId]
            setIsDirty(true)
            return newTags
        })
    }, [])

    // Keyboard shortcuts
    useEffect(() => {
        const handleKeyDown = (e) => {
            // Cmd/Ctrl + ,: Open Settings
            if ((e.metaKey || e.ctrlKey) && e.key === ',') {
                e.preventDefault()
                setSettingsOpen(true)
            }
            
            // Esc: Close Settings
            if (e.key === 'Escape' && settingsOpen) {
                setSettingsOpen(false)
            }
        }

        window.addEventListener('keydown', handleKeyDown)
        return () => window.removeEventListener('keydown', handleKeyDown)
    }, [settingsOpen])

    // Warn about unsaved changes
    useEffect(() => {
        const handleBeforeUnload = (e) => {
            if (isDirty) {
                e.preventDefault()
                e.returnValue = 'You have unsaved changes. Are you sure you want to leave?'
                return e.returnValue
            }
        }

        window.addEventListener('beforeunload', handleBeforeUnload)
        return () => window.removeEventListener('beforeunload', handleBeforeUnload)
    }, [isDirty])

    // Cleanup auto-save timer on unmount
    useEffect(() => {
        return () => {
            if (autoSaveTimeoutRef.current) {
                clearTimeout(autoSaveTimeoutRef.current)
            }
        }
    }, [])

    // Pause autosave while settings are open
    useEffect(() => {
        if (settingsOpen && autoSaveTimeoutRef.current) {
            clearTimeout(autoSaveTimeoutRef.current)
        }
    }, [settingsOpen])

    const defaultValues = {
        title: extractedTitle,
        content: '',
        content_blocks: initialValues.content_blocks || null,
        ...initialValues
    }

    return (
        <div className="editor-only-post">
            <Formik
                initialValues={defaultValues}
                validationSchema={EditorOnlySchema}
                onSubmit={() => {}} // Not used - we handle submission manually
                enableReinitialize={true}
            >
                {({ values, setFieldValue }) => (
                    <Form className="h-full flex flex-col">
                        {/* Floating Toolbar */}
                        <FloatingToolbar
                            onPublish={() => {
                                // Seed dialog state from current selections
                                setPublishCategoryId(categoryId || '')
                                setPublishTags(selectedTags || [])
                                setPublishFeaturedFile(null)
                                setPublishFeaturedPreview(null)
                                setPublishOpen(true)
                            }}
                            saveStatus={saveStatus}
                            lastSaved={lastSaved}
                            isSaving={false}
                            isPublishing={isPublishing}
                            onOpenSettings={() => setSettingsOpen(true)}
                            readingTime={stats.readingTime}
                            wordCount={stats.wordCount}
                        />

                        {/* Main Editor Area */}
                        <div className="editor-main-content">
                            <div className="editor-container">
                                <BlockEditor
                                    name="content_blocks"
                                    fullHeight={true}
                                    placeholder="Start with a title or just begin writing..."
                                    onContentChange={(contentData) => handleContentChange(contentData, setFieldValue)}
                                    showErrorMsg={false}
                                />
                            </div>
                        </div>

                        {/* Settings Sidebar */}
                        <PostSettingsSidebar
                            isOpen={settingsOpen}
                            onClose={() => setSettingsOpen(false)}
                            excerpt={manualExcerpt}
                            autoExcerpt={autoGeneratedExcerpt}
                            useAutoExcerpt={useAutoExcerpt}
                            onExcerptModeChange={setUseAutoExcerpt}
                            onExcerptChange={setManualExcerpt}
                            categories={categories}
                            categoryId={categoryId}
                            onCategoryChange={setCategoryId}
                            tags={tags}
                            selectedTags={selectedTags}
                            onTagToggle={handleTagToggle}
                            metaTitle={metaTitle}
                            metaDescription={metaDescription}
                            readingTime={stats.readingTime}
                            onMetaChange={(updates) => {
                                if (updates.metaTitle !== undefined) setMetaTitle(updates.metaTitle)
                                if (updates.metaDescription !== undefined) setMetaDescription(updates.metaDescription)
                                if (updates.readingTime !== undefined) setCustomReadingTime(updates.readingTime)
                                setIsDirty(true)
                            }}
                            categoriesLoading={categoriesLoading}
                            tagsLoading={tagsLoading}
                        />

                        {/* Publish Dialog */}
                        {publishOpen && (
                            <div className="fixed inset-0 z-50">
                                <div className="absolute inset-0 bg-black bg-opacity-50" onClick={() => setPublishOpen(false)} />
                                <div className="absolute inset-0 flex items-center justify-center p-4">
                                    <div className="bg-white w-full max-w-xl rounded-lg shadow-xl">
                                        <div className="px-5 py-4 border-b">
                                            <h3 className="text-lg font-semibold text-darkgray">Ready to publish?</h3>
                                            <p className="text-sm text-gray-500">Choose category, up to 5 tags, and a feature image.</p>
                                        </div>
                                        <div className="px-5 py-4 space-y-5 max-h-[70vh] overflow-y-auto">
                                            {/* Category */}
                                            <div>
                                                <label className="block text-sm font-medium text-darkgray mb-2">Category</label>
                                                <select
                                                    value={publishCategoryId || ''}
                                                    onChange={(e) => setPublishCategoryId(e.target.value)}
                                                    className="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:border-fastblue focus:outline-none"
                                                >
                                                    <option value="">No category</option>
                                                    {categories.map((c) => (
                                                        <option key={c.id} value={c.id}>{c.name}</option>
                                                    ))}
                                                </select>
                                            </div>
                                            {/* Tags */}
                                            <div>
                                                <div className="flex items-center justify-between mb-2">
                                                    <label className="block text-sm font-medium text-darkgray">Tags</label>
                                                    <span className="text-xs text-gray-500">{publishTags.length}/5</span>
                                                </div>
                                                {tagsLoading ? (
                                                    <p className="text-sm text-gray-500">Loading tags...</p>
                                                ) : (
                                                    <div className="flex flex-wrap gap-2">
                                                        {tags.map(tag => {
                                                            const active = publishTags.includes(tag.id)
                                                            const disabled = !active && publishTags.length >= 5
                                                            return (
                                                                <button
                                                                    key={tag.id}
                                                                    type="button"
                                                                    disabled={disabled}
                                                                    onClick={() => {
                                                                        setPublishTags(prev => {
                                                                            if (prev.includes(tag.id)) return prev.filter(id => id !== tag.id)
                                                                            if (prev.length >= 5) return prev
                                                                            return [...prev, tag.id]
                                                                        })
                                                                    }}
                                                                    className={`px-3 py-1 rounded-full text-xs border transition-all ${active ? 'bg-fastblue text-white border-fastblue' : 'bg-white text-darkgray border-[#dfdfdf] hover:border-fastblue'} ${disabled ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                                >
                                                                    {tag.name}
                                                                </button>
                                                            )
                                                        })}
                                                    </div>
                                                )}
                                            </div>
                                            {/* Feature Image */}
                                            <div>
                                                <label className="block text-sm font-medium text-darkgray mb-2">Feature Image</label>
                                                <div className="border-2 border-dashed border-gray-300 rounded-lg p-4 text-center">
                                                    {publishFeaturedPreview ? (
                                                        <img src={publishFeaturedPreview} alt="Preview" className="max-h-40 mx-auto rounded" />
                                                    ) : (
                                                        <p className="text-xs text-gray-500">Optional. JPG/PNG/GIF/WEBP up to 5MB.</p>
                                                    )}
                                                    <input
                                                        type="file"
                                                        accept="image/*"
                                                        onChange={(e) => {
                                                            const file = e.target.files?.[0]
                                                            if (!file) return
                                                            if (!file.type.startsWith('image/')) return alert('Please select an image file')
                                                            if (file.size > 5 * 1024 * 1024) return alert('Image must be under 5MB')
                                                            setPublishFeaturedFile(file)
                                                            const r = new FileReader()
                                                            r.onload = (ev) => setPublishFeaturedPreview(ev.target.result)
                                                            r.readAsDataURL(file)
                                                        }}
                                                        className="mt-3 w-full text-sm"
                                                    />
                                                </div>
                                            </div>
                                        </div>
                                        <div className="px-5 py-4 border-t flex justify-end gap-2">
                                            <button type="button" className="px-4 py-2 text-sm border rounded-md" onClick={() => setPublishOpen(false)}>Cancel</button>
                                            <button
                                                type="button"
                                                className="px-4 py-2 text-sm bg-fastblue text-white rounded-md"
                                                onClick={async () => {
                                                    setPublishOpen(false)
                                                    await handlePublish(values, {
                                                        featuredFile: publishFeaturedFile || undefined,
                                                        categoryId: publishCategoryId,
                                                        tagIds: publishTags
                                                    })
                                                }}
                                            >
                                                Publish
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                    </Form>
                )}
            </Formik>
        </div>
    )
}

EditorOnlyPostForm.propTypes = {
    initialValues: PropTypes.object,
    onSubmit: PropTypes.func.isRequired,
    onSaveDraft: PropTypes.func,
    loading: PropTypes.bool,
    isEditMode: PropTypes.bool
}

export default EditorOnlyPostForm
