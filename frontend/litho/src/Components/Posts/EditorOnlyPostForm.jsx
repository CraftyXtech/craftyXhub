import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react'
import PropTypes from 'prop-types'

// Libraries
import { Formik, Form } from 'formik'
import * as Yup from 'yup'

// Components
import { BlockEditor } from '../Form/Form'
import FloatingToolbar from './FloatingToolbar'
import PostSettingsSidebar from './PostSettingsSidebar'

// API & Auth
import { useCategories, useTags } from '../../api/usePosts'

// Utilities
import {
    extractTitle,
    calculateWordCount,
    calculateReadingTime,
    generateExcerpt,
    extractPlainText
} from '../../utils/editorUtils'

// CSS
import "../../Assets/scss/components/_editor-only-post.scss"

// Validation schema (simplified - only validate content exists)
const EditorOnlySchema = Yup.object().shape({
    content: Yup.string()
        .min(50, 'Content must be at least 50 characters')
        .required('Content is required')
        .test('content-length', 'Content must be at least 50 characters', function(value) {
            const textContent = value ? value.replace(/<[^>]*>/g, '').trim() : '';
            return textContent.length >= 50;
        })
})

const EditorOnlyPostForm = ({
    initialValues = {},
    onSubmit,
    onSaveDraft,
    loading = false,
    isEditMode = false
}) => {
    // Form state
    const [editorData, setEditorData] = useState(null)
    const [settingsOpen, setSettingsOpen] = useState(false)
    const [isDirty, setIsDirty] = useState(false)
    
    // Metadata state
    const [featuredImage, setFeaturedImage] = useState(null)
    const [featuredImagePreview, setFeaturedImagePreview] = useState(initialValues.featured_image || null)
    const [useAutoExcerpt, setUseAutoExcerpt] = useState(true)
    const [manualExcerpt, setManualExcerpt] = useState(initialValues.excerpt || '')
    const [categoryId, setCategoryId] = useState(initialValues.category_id || '')
    const [selectedTags, setSelectedTags] = useState(initialValues.tag_ids || [])
    const [metaTitle, setMetaTitle] = useState(initialValues.meta_title || '')
    const [metaDescription, setMetaDescription] = useState(initialValues.meta_description || '')
    const [customReadingTime, setCustomReadingTime] = useState(initialValues.reading_time || null)
    
    // Auto-save state
    const [saveStatus, setSaveStatus] = useState('idle')
    const [lastSaved, setLastSaved] = useState(null)
    const autoSaveTimeoutRef = useRef(null)
    
    // API hooks
    const { categories, loading: categoriesLoading } = useCategories()
    const { tags, loading: tagsLoading } = useTags()

    // Auto-computed values
    const stats = useMemo(() => {
        if (!editorData?.blocks) return { wordCount: 0, readingTime: 1 }
        
        const wordCount = calculateWordCount(editorData)
        const readingTime = customReadingTime || calculateReadingTime(wordCount)
        
        return { wordCount, readingTime }
    }, [editorData, customReadingTime])

    const autoGeneratedExcerpt = useMemo(() => {
        if (!editorData?.blocks) return ''
        return generateExcerpt(editorData, 150)
    }, [editorData])

    const extractedTitle = useMemo(() => {
        if (!editorData?.blocks) return ''
        return extractTitle(editorData)
    }, [editorData])

    // Handle editor content changes
    const handleContentChange = useCallback((contentData, setFieldValue) => {
        setEditorData(contentData.blocks)
        setFieldValue('content_blocks', contentData.blocks)
        setFieldValue('content', contentData.html)
        setIsDirty(true)
        
        // Trigger auto-save timer
        if (autoSaveTimeoutRef.current) {
            clearTimeout(autoSaveTimeoutRef.current)
        }
        
        autoSaveTimeoutRef.current = setTimeout(() => {
            if (onSaveDraft) {
                handleAutoSave(contentData)
            }
        }, 30000) // 30 seconds
    }, [onSaveDraft])

    // Auto-save function
    const handleAutoSave = useCallback(async (contentData) => {
        if (!contentData?.blocks || contentData.blocks.length === 0) return
        
        try {
            setSaveStatus('saving')
            
            const draftData = {
                content: contentData.html,
                content_blocks: contentData.blocks,
                excerpt: useAutoExcerpt ? autoGeneratedExcerpt : manualExcerpt,
                category_id: categoryId,
                tag_ids: selectedTags,
                featured_image: featuredImage,
                meta_title: metaTitle,
                meta_description: metaDescription,
                reading_time: stats.readingTime,
                slug: '', // Will be auto-generated from title
                is_published: false
            }
            
            await onSaveDraft(draftData)
            setSaveStatus('saved')
            setLastSaved(Date.now())
            setIsDirty(false)
        } catch (error) {
            console.error('Auto-save failed:', error)
            setSaveStatus('error')
        }
    }, [
        useAutoExcerpt,
        autoGeneratedExcerpt,
        manualExcerpt,
        categoryId,
        selectedTags,
        featuredImage,
        metaTitle,
        metaDescription,
        stats.readingTime,
        onSaveDraft
    ])

    // Manual save draft
    const handleSaveDraft = useCallback(async (values) => {
        if (!editorData?.blocks || editorData.blocks.length === 0) {
            alert('Please write some content before saving')
            return
        }

        try {
            setSaveStatus('saving')
            
            const draftData = {
                content: values.content,
                content_blocks: values.content_blocks,
                excerpt: useAutoExcerpt ? autoGeneratedExcerpt : manualExcerpt,
                category_id: categoryId,
                tag_ids: selectedTags,
                featured_image: featuredImage,
                meta_title: metaTitle,
                meta_description: metaDescription,
                reading_time: stats.readingTime,
                slug: '', // Will be auto-generated from title
                is_published: false
            }
            
            await onSaveDraft(draftData)
            setSaveStatus('saved')
            setLastSaved(Date.now())
            setIsDirty(false)
        } catch (error) {
            console.error('Save draft failed:', error)
            setSaveStatus('error')
            alert(error.message || 'Failed to save draft')
        }
    }, [
        editorData,
        useAutoExcerpt,
        autoGeneratedExcerpt,
        manualExcerpt,
        categoryId,
        selectedTags,
        featuredImage,
        metaTitle,
        metaDescription,
        stats.readingTime,
        onSaveDraft
    ])

    // Publish post
    const handlePublish = useCallback(async (values) => {
        if (!editorData?.blocks || editorData.blocks.length === 0) {
            alert('Please write some content before publishing')
            return
        }

        // Validate minimum content length
        const plainText = extractPlainText(editorData)
        if (plainText.length < 50) {
            alert('Content must be at least 50 characters')
            return
        }

        try {
            const postData = {
                content: values.content,
                content_blocks: values.content_blocks,
                excerpt: useAutoExcerpt ? autoGeneratedExcerpt : manualExcerpt,
                category_id: categoryId,
                tag_ids: selectedTags,
                featured_image: featuredImage,
                meta_title: metaTitle,
                meta_description: metaDescription,
                reading_time: stats.readingTime,
                slug: '', // Will be auto-generated from title
                is_published: true
            }
            
            await onSubmit(postData)
            setIsDirty(false)
        } catch (error) {
            console.error('Publish failed:', error)
            alert(error.message || 'Failed to publish post')
        }
    }, [
        editorData,
        useAutoExcerpt,
        autoGeneratedExcerpt,
        manualExcerpt,
        categoryId,
        selectedTags,
        featuredImage,
        metaTitle,
        metaDescription,
        stats.readingTime,
        onSubmit
    ])

    // Handle featured image change
    const handleImageChange = useCallback((file) => {
        if (!file.type.startsWith('image/')) {
            alert('Please select a valid image file')
            return
        }

        if (file.size > 10 * 1024 * 1024) {
            alert('Image size must be less than 10MB')
            return
        }

        setFeaturedImage(file)
        
        const reader = new FileReader()
        reader.onload = (e) => {
            setFeaturedImagePreview(e.target.result)
        }
        reader.readAsDataURL(file)
        setIsDirty(true)
    }, [])

    const handleImageRemove = useCallback(() => {
        setFeaturedImage(null)
        setFeaturedImagePreview(null)
        setIsDirty(true)
    }, [])

    // Handle tag toggle
    const handleTagToggle = useCallback((tagId) => {
        setSelectedTags(prev => {
            const newTags = prev.includes(tagId)
                ? prev.filter(id => id !== tagId)
                : [...prev, tagId]
            setIsDirty(true)
            return newTags
        })
    }, [])

    // Keyboard shortcuts
    useEffect(() => {
        const handleKeyDown = (e) => {
            // Cmd/Ctrl + ,: Open Settings
            if ((e.metaKey || e.ctrlKey) && e.key === ',') {
                e.preventDefault()
                setSettingsOpen(true)
            }
            
            // Esc: Close Settings
            if (e.key === 'Escape' && settingsOpen) {
                setSettingsOpen(false)
            }
        }

        window.addEventListener('keydown', handleKeyDown)
        return () => window.removeEventListener('keydown', handleKeyDown)
    }, [settingsOpen])

    // Warn about unsaved changes
    useEffect(() => {
        const handleBeforeUnload = (e) => {
            if (isDirty) {
                e.preventDefault()
                e.returnValue = 'You have unsaved changes. Are you sure you want to leave?'
                return e.returnValue
            }
        }

        window.addEventListener('beforeunload', handleBeforeUnload)
        return () => window.removeEventListener('beforeunload', handleBeforeUnload)
    }, [isDirty])

    // Cleanup auto-save timer on unmount
    useEffect(() => {
        return () => {
            if (autoSaveTimeoutRef.current) {
                clearTimeout(autoSaveTimeoutRef.current)
            }
        }
    }, [])

    const defaultValues = {
        title: extractedTitle,
        content: '',
        content_blocks: initialValues.content_blocks || null,
        ...initialValues
    }

    return (
        <div className="editor-only-post">
            <Formik
                initialValues={defaultValues}
                validationSchema={EditorOnlySchema}
                onSubmit={() => {}} // Not used - we handle submission manually
                enableReinitialize={true}
            >
                {({ values, setFieldValue, isSubmitting }) => (
                    <Form className="h-full flex flex-col">
                        {/* Floating Toolbar */}
                        <FloatingToolbar
                            onPublish={() => handlePublish(values)}
                            saveStatus={saveStatus}
                            lastSaved={lastSaved}
                            isSaving={false}
                            isPublishing={isSubmitting || loading}
                            onOpenSettings={() => setSettingsOpen(true)}
                            readingTime={stats.readingTime}
                            wordCount={stats.wordCount}
                        />

                        {/* Main Editor Area */}
                        <div className="editor-main-content">
                            <div className="editor-container">
                                <BlockEditor
                                    name="content_blocks"
                                    fullHeight={true}
                                    placeholder="Start with a title or just begin writing..."
                                    onContentChange={(contentData) => handleContentChange(contentData, setFieldValue)}
                                    showErrorMsg={false}
                                />
                            </div>
                        </div>

                        {/* Settings Sidebar */}
                        <PostSettingsSidebar
                            isOpen={settingsOpen}
                            onClose={() => setSettingsOpen(false)}
                            featuredImage={featuredImage}
                            featuredImagePreview={featuredImagePreview}
                            onImageChange={handleImageChange}
                            onImageRemove={handleImageRemove}
                            excerpt={manualExcerpt}
                            autoExcerpt={autoGeneratedExcerpt}
                            useAutoExcerpt={useAutoExcerpt}
                            onExcerptModeChange={setUseAutoExcerpt}
                            onExcerptChange={setManualExcerpt}
                            categories={categories}
                            categoryId={categoryId}
                            onCategoryChange={setCategoryId}
                            tags={tags}
                            selectedTags={selectedTags}
                            onTagToggle={handleTagToggle}
                            metaTitle={metaTitle}
                            metaDescription={metaDescription}
                            readingTime={stats.readingTime}
                            onMetaChange={(updates) => {
                                if (updates.metaTitle !== undefined) setMetaTitle(updates.metaTitle)
                                if (updates.metaDescription !== undefined) setMetaDescription(updates.metaDescription)
                                if (updates.readingTime !== undefined) setCustomReadingTime(updates.readingTime)
                                setIsDirty(true)
                            }}
                            categoriesLoading={categoriesLoading}
                            tagsLoading={tagsLoading}
                        />
                    </Form>
                )}
            </Formik>
        </div>
    )
}

EditorOnlyPostForm.propTypes = {
    initialValues: PropTypes.object,
    onSubmit: PropTypes.func.isRequired,
    onSaveDraft: PropTypes.func,
    loading: PropTypes.bool,
    isEditMode: PropTypes.bool
}

export default EditorOnlyPostForm
